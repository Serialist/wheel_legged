# DEVLOG

## 2025-12-02

创世版本，开始使用 GIT。

## 2025-12-05

下午计划：

1. 修改交互逻辑 v0.1.0 版本，移植到控制量层次
2. 添加拨盘和 yaw 电机控制
3. 如果轮毂装上，调试跳跃

完成情况：

1. 逻辑没移植完

2. 电机也没写666

3. 装了一晚上轮毂

   - 电机0：捡来的，三相线接触不良
   - 电机1：步改哨摩擦轮，输出齿轮比别的都小，不知道这是什么版本的电机
   - 电机2：来源同上，输出齿轮有一个齿坏了，碰上会一卡一卡的

   寄，没找到好的电机

4. 平衡功能大概正常，因为电机0接触不良不能测

总结：大寄特寄。

明日计划：

1. 电机1和2都好的，换掉老步兵摩擦轮，安装
2. 测跳跃

## 2025-12-14

解耦所有嵌入式代码

背景：移植 MCU 型号，改逻辑，改通信接口交互接口协议的必要性。目标是在任何地方，不仅限于嵌入式，都可以单独使用其中的代码模块。

初步设想：

1. 一个嵌入式框架，规定对外接口
2. 硬件适配方案：一个 adapter 库，子库如数学库、常用操作库、常用可优化操作库等
3. 分层设计，添加设计规范和层间通信协议
4. 将所有逻辑代码分开，以便于改操作逻辑
5. 将底层代码分开，使用注册器方式注册外设驱动，有点类似于中断向量表

分层设计：

1. 核心驱动：硬件底层，调用核心、片内外设

2. 外层驱动：调用核心驱动，和芯片硬件分离，管理板级外设、板件外外设，使用注册表

3. 中间件-系统层：关联处理器核心，进行多线程操作

4. 中间件-工具层：实际上脱离所有层，所有层级都可以调用

   - 算法层：各种算法，如排序、滤波等
   - 模块库：提供常用操作
   - 数学库：数学运算（这里可以对应初步设想 2 的的逻辑）

5. 应用层：最外层，调用以上的所有最上级接口，是应用逻辑层

   功能：指令 $\rightarrow$ 控制

   - 指令就是用户交互层，用户不仅仅之人，也可以指其他程序，或者或“所有按照规定协议使用接口的上层对象”。这一层的目的是分离操作逻辑，也可看为一个 adapter，把通用的交互接口对接为程序逻辑单元
   - 控制是核心部分，调用硬件，按照逻辑和算法库进行操作

关于模块/对象的想法：、

1. 模块是什么：模块（module），或者说对象（object），在这里，我定义模块为一个独立运行的程序单元。实现一定功能、对外提供接口及其协议，就可以定义为一个模块

2. 模块的生命历程：

   模块由另一个模块构成，这个过程叫构造（construct），构造时使用的模板是类型（class），对象是类的实例（instance）。

例如 STM32 的 CAN 外设：

- 创建：外设寄存器和功能的初始化
- 回调注册：注册不同实现的回调函数，如
  - 不同 ID 的总线信息的处理程序（如注册一个电机）
  - error handler
- 发送函数：帧的元信息，ID 信息，数据
- 注销函数，析构函数

## 2025-12-19

考完试，开始调。

机械装好新限位，根据上交的轮腿。但是由于电机在装配时角度有误差，要重新校准。软件加 offset 但是不知道为什么会疯。

## 2025-12-20

装好了导轮，起立还好，但是二级倒立摆走起来不知道为什么有点疯。不知道是不是 LQR 调参的问题，但是 LQR调参问题会有这么大影响吗。

~~好累，想去玩无线电。~~
